
# create tuple for new show
# find if target_tuple is in existing LIVE_list
# if it is
#       @@ list maintenance
#       find where it will come from in list (current_position)
#       get list of positions to reduce by 1 Set(X) -- range(current_position , len(list))
#       find where it will go in the list (insert_position)
#       get list of positions to increase by 1 Set(Z) -- range(insert_position, len(list))
#
#       @@ store maintenance
#       clear property of target_tuple stored position ID
#       find the difference between Set(X) and Set(Z) -- X.difference(Z) and reduce their stored position ID by 1 starting with lowest first
#       find the difference between Set(Z) and Set(X) -- Z.difference(X) and increase their stored position ID by 1 starting with highest first
#       insert new tuple in stored position ID




def r ():
    global a
    a = [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'),(5,'e')]
    print a


def what_happens(item_tuple, LIVE_list):

    #item = (199, 'c')
    hh = [x for x in a if x[1] = item_tuple[1]]
    if hh:
        comes_from = a.index[hh]
    else:
        comes_from = len(a)
    decrease_positions = set(range(comes_from,len(a)))

    #item = (199, 'c')
    nearest = a.index(min(a, key=lambda x:abs(x[0]-item_tuple[0])))
    #if the closest value is higher than the added value
    if a[nearest][0] > mvo[0]:
        #insert after
        goes_into = nearest +1
    else:
        #insert before
        goes_into = nearest

    increase_positions = set(range(goes_into, len(a)))

    net_increase = increase_positions.difference(decrease_positions)
    net_decrease = decrease_positions.difference(increase_positions)

    return net_increase, net_decrease, goes_into, comes_from


def make_change_list(item_tuple, comes_from, goes_into):
    #remove item from list
    a.remove(comes_from)
    #add item to the list
    a[goes_into] = item_tuple


def make_change_stored_IDs(net_increase, net_decrease, comes_from, goes_into, new_property_dict):
    #remove current stored_ID
    abc.clearproperty('prop_%s' % comes_from)
    'for all properties'

    #process increase positions
    inc = list(net_increase).sort(reverse=True)

    for x in inc:
        abc.setprop('prop_%s' % x + 1, abc.getprop('prop_%s' % x))
        'for all properties'

    #process decrease positions
    dec = list(net_decrease).sort()

    for x in dec:
        abc.setprop('prop_%s' % x - 1, abc.getprop('prop_%s' % x))
        'for all properties'

    abc.setprop('prop_%s', goes_into, new_property_dict['prop'])
    'for all properties'


def create_playlist():
    #creates a random playlist of unwatched episodes

    #clears the playlist
    json_query(clear_playlist, False)

    #generates the show and episode lists
    playlist_showids, all_shows = populate_by_x()

    #updates progross dialog

    #notifies the user when there is no shows in the show list
    if not playlist_showids and partial_exists == False:
        dialog.ok('LazyTV', lang(32150))

    #loop to add more files to the playlist, the loop carries on until the playlist is full or not shows are left in the show list
    while itera in range((settings['playlist_length']-1) if partial_exists == True else settings['playlist_length']):

        #counts the number of shows in the showlist, if it is ever empty, the loop ends
        show_count = len(playlist_showids)
        if show_count == 0 or not playlist_showids:
            itera = 10000

        else:

            #selects a show at random from the show list
            R = random.randint(0,show_count - 1)
            SHOWID = playlist_showids[R]

            #gets the details of that show and the shows episodes
            this_show = [x for x in all_shows if x['tvshowid'] == SHOWID][0]

            eps_query['params']['tvshowid'] = SHOWID
            ep = json_query(eps_query, True)

            #accounts for the query not returning any TV shows
            if 'episodes' not in ep:
                gracefail(lang(32203))
            else:
                eps = ep['episodes']

            #ascertains the appropriate season and episode number of the last watched show
            if SHOWID in playlist_tally:

                #if the show is already in the tally, then use that entry as the last show watched
                Season  = playlist_tally[SHOWID][0]
                Episode = playlist_tally[SHOWID][1]

            elif this_show['watchedepisodes'] == 0:
                #if the show doesnt have any watched episodes, the season and episode are both zero
                Season  = 0
                Episode = 0

            else:
                #creates a list of episodes for the show that have been watched
                played_eps = [x for x in eps if x['playcount'] is not 0 and x['tvshowid'] == SHOWID]

                #the last played episode is the one with the highest season number and then the highest episode number
                last_played_ep = sorted(played_eps, key =  lambda played_eps: (played_eps['season'], played_eps['episode']), reverse=True)[0]
                Season = last_played_ep['season']
                Episode = last_played_ep['episode']

            #uses the season and episode number to create a list of unwatched shows newer than the last watched one
            unplayed_eps = [x for x in eps if ((x['season'] == Season and x['episode'] > Episode)
            or (x['season'] > Season)) and x['tvshowid'] == SHOWID]

            #sorts the list of unwatched shows by lowest season and lowest episode, filters the list to remove empty strings
            next_ep = sorted(unplayed_eps, key = lambda unplayed_eps: (unplayed_eps['season'], unplayed_eps['episode']))
            next_ep = filter(None, next_ep)

            #if there is no next episode then remove the show from the show list, and start again
            #removes the next_ep if it is the first in the series and premieres arent wanted,
            #or the show is partially watched and expartials is true
            if not next_ep or (Season == 1 and Episode == 1 and settings['premieres'] == 'false') or (settings['expartials'] == 'true' and next_ep[0]['resume']['position'] == 0):
                playlist_showids = [x for x in playlist_showids if x != SHOWID]
            else:
                next_ep = next_ep[0]

                #creates safe version of next episode
                clean_next_ep = next_ep

                #cleans the name, letters such as Ã  were breaking the search for .strm in the name
                dirty_name = clean_next_ep['file']
                clean_name = fix_name(dirty_name).lower()

                #only processes files that arent streams or that are streams but the user has specified that that is ok and either it isnt the first entry in the list or there is already a partial running
                if ".strm" not in clean_name or (".strm" in clean_name and settings['streams'] == 'true'):# and (itera != 0 or partial_exists == True)):

                    #adds the file to the playlist
                    json_query(dict_engine(next_ep['episodeid'],'episodeid'), False)

                    #if the user doesnt want multiples then the file is removed from the list, otherwise the episode is added to the tally list
                    if settings['multiples'] == 'false':
                        playlist_showids = [x for x in playlist_showids if x != SHOWID]
                    else:
                        playlist_tally[SHOWID] = (next_ep['season'],next_ep['episode'])

                    #starts the player if this is the first entry, seeks to the right point if resume selected
                    if itera == 0 and ".strm" not in clean_name:

                        norm_start = True
                        xbmc.Player().play(xbmc.PlayList(1))

                        if settings['resume_partials'] == 'true' and next_ep['resume']['total'] != 0:

                            #IF RESUMES WANTED THEN CHECK IF THIS IS A RESUME, IF IT IS THEN SEEK TO THE APPROPRIATE LOCATION
                            #jumps to resume point of the partial

                            seek_percent = float(next_ep['resume']['position'])/float(next_ep['resume']['total'])*100.0

                            seek['params']['value'] = seek_percent

                            json_query(seek, False)

                    elif next_ep['resume']['position'] != 0 and settings['resume_partials'] == 'true':
                        show_key = str(this_show['title']) + 'S' + str(next_ep['season']) + 'E' + str(next_ep['episode'])
                        resume_dict[show_key] = float(next_ep['resume']['position'])/float(next_ep['resume']['total'])*100.0

                    if ".strm" in clean_name:
                        plist_has_strm = True

                    #records a file was added to the playlist
                    itera +=1

                #if the next episode is a stream and the user doesnt want streams, the show is removed from the show list
                elif ".strm" in clean_name and settings['streams'] == 'false':
                    playlist_showids = [x for x in playlist_showids if x != SHOWID]

                #records that he loop has completed one more time
                cycle +=1

                #infinite loop escape, is triggered if the cycle has run 100 times and streams are not allowed or there hasnt been anything added to the playlist
                #this may occur if all episodes of all shows are strms and strms are not permitted
                #if all the shows are streams, then exit the loop, otherwise, keep trying another 100 times
                if cycle % 100 == 0 and _checked == False and (settings['streams'] == 'false' or itera == 0):
                    #confirm all eps are streams
                    check_eps = [fix_name(x['file']) for x in eps if x['tvshowid'] in playlist_showids]
                    if all(".strm" in ep.lower() for ep in check_eps):
                        itera = 1000
                    _checked = True


    if itera != 0:
        if not plist_has_strm and (settings['notify'] == 'true' or settings['resume_partials'] == 'true'):
            play_monitor = MyPlayer()

            while not xbmc.abortRequested and play_monitor.player_active:
                xbmc.sleep(100)

        elif norm_start:
            pass
        else:
            xbmc.Player().play(xbmc.PlayList(1))


    #print 'final end'

